<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>HW 6 Ray Tracing</title>
    <style>
    body { 
        margin: 0; 
        background: #111; 
        color: #ccc;
        font-family: monospace;
        padding: 20px;
    }
    textarea {
        background: #222;
        color: #0f0;
        font: 14px monospace;
        width: 800px;
        height: 600px;
    }
    canvas {
        border: 1px solid #444;
    }
    .container {
        display: flex;
        gap: 20px;
        align-items: flex-start;
    }

    .canvas-container {
        display: flex;
        flex-direction: column;
    }

    .editor-panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .controls {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    
    .control-section {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .control-title {
        font-weight: bold;
        font-size: 14px;
    }
    
    .button-group {
        display: flex;
        gap: 10px;
    }
    
    button {
        background: #333;
        color: #ccc;
        border: 1px solid #555;
        padding: 8px 16px;
        cursor: pointer;
        font-family: monospace;
        font-size: 13px;
    }
    
    button:hover {
        background: #444;
    }
    
    button.active {
        background: #0a5;
        border-color: #0c7;
    }
    
    .slider-container {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    
    .slider-container label {
        font-size: 13px;
    }
    
    input[type="range"] {
        width: 300px;
    }
    
    .slider-value {
        color: #0a5;
        font-weight: bold;
    }
</style>
</head>
<body>

<h2>HW 6 ATOM In A Bottle</h2>
<p>The scene is suppose to represent and attom with electrons rotating around the nucleus. The gray and green spheres are<br>
diffuse, the white and red are reflective, and the blue is refractive. The base prism is diffuse. However, I know that it<br>
is slightly difficult tosee the refractivity of the blue sphere so I added some "bottle types" which encapsulates the atom <br>
into a refractive bottle. The speed slider will allow you to change the speed the atom is moving at and the bounces <br>
slider will allow you to control the number of max bounces for the rays in the scene. Finally I added the ability to see <br>
the scene in an infinity cube where the walls are all mirrors (done with 5 mirror cubes).<br>
If the reflection or the refraction begins to appear black when changing the bottle types or when doing the infinity cube<br>
then try increasing the number of bounces.
Please copy your edits to the source code if you want to save them, as the playground doesn't save them to the file.</p>

<div class="container">
    <div class="canvas-container">
        <canvas id="glCanvas" width="800" height="800"></canvas>
        
        <div class="controls">
            <!-- Bottle Type -->
            <div class="control-section">
                <div class="control-title">Bottle Type</div>
                <div class="button-group">
                    <button id="btn-none" class="bottle-btn active">None</button>
                    <button id="btn-sphere" class="bottle-btn">Sphere</button>
                    <button id="btn-jar" class="bottle-btn">Jar</button>
                </div>
            </div>
            
            <!-- Sliders -->
            <div class="control-section">
                <div class="slider-container">
                    <label>Speed: <span class="slider-value" id="speed-value">1.0</span></label>
                    <input type="range" id="speed-slider" min="0" max="200" value="100" step="1">
                </div>
                
                <div class="slider-container">
                    <label>Number of Bounces: <span class="slider-value" id="bounces-value">8</span></label>
                    <input type="range" id="bounces-slider" min="1" max="16" value="8" step="1">
                </div>

                <div class="slider-container">
                    <label>Ambient Strength: <span class="slider-value" id="strength-value">0.2</span></label>
                    <input type="range" id="strength-slider" min="0" max="100" value="20" step="10">
                </div>
            </div>
            
            <!-- Mode Buttons -->
            <div class="control-section">
                <div class="button-group">
                    <button id="btn-normal" class="mode-btn active">Normal</button>
                    <button id="btn-infinity" class="mode-btn">Infinity Cube</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="editor-panel">
         <div>
            <b>Fragment Shader</b><br>
            <textarea id="fsEditor"></textarea>
        </div>
        <div>
            <b>Vertex Shader</b><br>
            <textarea id="vsEditor"></textarea>
        </div>
    </div>
</div>
    


<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
    in vec2 position;
    void main() {
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;

    //time for animation
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform int u_maxBounces;
    uniform float u_ambientStrength;
    uniform float u_speed;
    uniform int u_bottle;
    uniform bool u_mirror;

    out vec4 fragColor;

    // Material types
    const int MATERIAL_DIFFUSE = 0;
    const int MATERIAL_REFLECTIVE = 1;
    const int MATERIAL_REFRACTIVE = 2;
    const int MATERIAL_EMISSION = 3;
    const float epsilon = 0.001;

    // Ray structure
    struct Ray {
        vec3 origin;
        vec3 direction;
    };

    // Sphere structure
    struct Sphere {
        vec3 center;
        float radius;
        vec3 color;
        int material;
        float reflectivity;
        float refractiveIndex;
    };

    // Cube structure
    struct Cube {
        vec3 center;
        vec3 size;
        vec3 color;
        int material;
        float reflectivity;
    };

    // Hit record structure
    struct HitData {
        bool hit;
        float t;
        vec3 point;
        vec3 normal;
        vec3 color;
        int material;
        float reflectivity;
        float refractiveIndex;
        bool frontFace;
    };

    // Scene objects
    Sphere spheres[6];
    Sphere lightSphere;
    Cube cubes[9];

    void initScene(float time) {
        float orbitRadius = 0.25;
        // Light sphere
        lightSphere = Sphere(
            vec3( -orbitRadius * cos(time),0.6 ,-orbitRadius * sin(time)),
            0.05,
            vec3(1.0, 1.0, 1.0),
            MATERIAL_EMISSION,  
            0.0,
            0.0
        );

        float ftime = time * u_speed;
        
        if(u_bottle == 2){
            cubes[0] = Cube(
                vec3(0.0, -0.1, 0),
                vec3(0.6, 0.8, 0.6),
                vec3(0.6,0.8,0.9),
                MATERIAL_REFRACTIVE,
                0.6
            );
            cubes[1] = Cube(
                vec3(0.0, 0.35, 0),
                vec3(0.65, 0.1, 0.65),
                vec3(0.6,0.8,0.9),
                MATERIAL_REFRACTIVE,
                0.6
            );
        }
        cubes[2] = Cube(
            vec3(0.0, -0.5, 0),
            vec3(0.85, 0.1, 0.85),
            vec3(0.54,0.35,0.12),
            MATERIAL_DIFFUSE,
            0.6
        );
        if(u_mirror){
           cubes[3] = Cube(
            vec3(0.0, -1.0, 0),
            vec3(1.0, 1.0, 1.0),
            vec3(0.0, 0.0, 0.0),
            MATERIAL_REFLECTIVE,
            1.0
            ); 
            cubes[4] = Cube(
            vec3(0.0, 1.0, 0),
            vec3(1.0, 1.0, 1.0),
            vec3(0.0, 0.0, 0.0),
            MATERIAL_REFLECTIVE,
            1.0
            ); 
            cubes[5] = Cube(
            vec3(1.0, 0.0, 0),
            vec3(1.0, 1.0, 1.0),
            vec3(0.0, 0.0, 0.0),
            MATERIAL_REFLECTIVE,
            1.0
            ); 
            cubes[6] = Cube(
            vec3(-1.0, 0.0, 0),
            vec3(1.0, 1.0, 1.0),
            vec3(0.0, 0.0, 0.0),
            MATERIAL_REFLECTIVE,
            1.0
            ); 
            cubes[7] = Cube(
            vec3(0.0, 0.0, -1.0),
            vec3(1.0, 1.0, 1.0),
            vec3(0.0, 0.0, 0.0),
            MATERIAL_REFLECTIVE,
            1.0
            ); 
            
        }
        //vec3(0.0, -0.55, 0.0),
           // vec3(0.8, 0.1, 0.6),
           // vec3(0.1,0.1,0.1),
           // 0.6

        spheres[0] = Sphere(
            vec3(orbitRadius * sin(ftime), orbitRadius * sin(ftime), orbitRadius * cos(ftime)), 
            0.05,
            vec3(0.5,0.0,0.0),
            MATERIAL_REFLECTIVE,
            0.1,
            0.1
        );

        
        spheres[1] = Sphere(
            vec3(-orbitRadius * sin(ftime), orbitRadius * sin(ftime), orbitRadius * cos(ftime)),
            0.07,
            vec3(0.1,0.5,0.7),
            MATERIAL_REFRACTIVE,
            0.0, 
            1.5  
        );

        spheres[2] = Sphere(
            vec3(0, -orbitRadius * sin(ftime), -orbitRadius * cos(ftime)),
            0.05,
            vec3(0.3,0.8,0.5),
            MATERIAL_DIFFUSE,
            0.0, 
            1.5  
        );

        spheres[3] = Sphere(
            vec3(-orbitRadius * sin(ftime), 0, -orbitRadius * cos(ftime)),
            0.05,
            vec3(0.5,0.5,0.5),
            MATERIAL_REFLECTIVE,
            0.5, 
            1.5  
        );
        if(u_bottle == 1){
            spheres[4] = Sphere(
            vec3(0,0,0),
            0.45,
            vec3(0.6,0.8,0.9),
            MATERIAL_REFRACTIVE,
            0.0, 
            1.5  
            );
        }
        spheres[5] = Sphere(
            vec3(0,0,0),
            0.02,
            vec3(0.5,0.5,0.5),
            MATERIAL_DIFFUSE,
            0.0, 
            1.5  
        );
    }

    bool intersectSphere(Ray ray, Sphere sphere, out float t) {
        float a = dot(ray.direction, ray.direction);
        vec3 pc = ray.origin - sphere.center;
        float b = dot((2.0 * ray.direction), pc);
        float c = dot(pc, pc) - (sphere.radius * sphere.radius);
        float delta = b * b - 4.0 * a * c;
        if(delta < 0.0){
            return false;
        }
        float t0 = (-b - sqrt(delta)) / (2.0 * a);
        float t1 = (-b + sqrt(delta)) / (2.0 * a);

        t = t0 > 0.001 ? t0 : t1;
        return t > 0.001;
    }

    bool intersectCube(Ray ray, Cube cube, out float t, out vec3 normal) {
        vec3 minBound = cube.center - cube.size * 0.5;
        vec3 maxBound = cube.center + cube.size * 0.5;

        float tmin = -1e10;
        float tmax = 1e10;
        normal = vec3(0.0);
        int hitAxis = -1;

        for (int i = 0; i < 3; i++){
            if (abs(ray.direction[i]) < 0.001){
                if(ray.origin[i] < minBound[i] || ray.origin[i] > maxBound[i] ){
                    return false;
                }
            }
            float t1 = (minBound[i] - ray.origin[i]) / ray.direction[i];
            float t2 = (maxBound[i] - ray.origin[i]) / ray.direction[i];
            
            float tnear = min(t1, t2);
            float tfar = max(t1, t2);

            if(tnear > tmin){
                tmin = tnear;
                hitAxis = i;
            }
            if(tfar < tmax){
                tmax = tfar;
            }

            if(tmin > tmax){
                return false;
            }
        
        }
        if(tmin > 0.001){
            t = tmin;
            vec3 hitPoint = ray.origin + ray.direction * tmin;
            normal[hitAxis] = (hitPoint[hitAxis] > cube.center[hitAxis]) ? 1.0 : -1.0;
            return true;
        }        
        return false;
    }

    // Trace objects in the scene for intersections
    HitData traceScene(Ray ray, bool includeLightSphere) {
        HitData closest;
        closest.hit = false;
        closest.t = 1e10;

        // Light sphere intersection
        if (includeLightSphere) {
            float t;
            if (intersectSphere(ray, lightSphere, t)) {
                if (t < closest.t) {
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + ray.direction * closest.t;
                    closest.normal = normalize(closest.point - lightSphere.center);
                    closest.color = lightSphere.color;
                    closest.material = lightSphere.material;
                    closest.reflectivity = lightSphere.reflectivity;
                    closest.refractiveIndex = lightSphere.refractiveIndex;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                }
            }
        }

        // Cube intersection
        for(int i=0; i<cubes.length(); i++){
            float cube_t;
            vec3 cubeNormal;
            if (intersectCube(ray, cubes[i], cube_t, cubeNormal)) {
                if (cube_t < closest.t) {
                    closest.hit = true;
                    closest.t = cube_t;
                    closest.point = ray.origin + ray.direction * closest.t;
                    closest.normal = cubeNormal;
                    closest.color = cubes[i].color;
                    closest.material = cubes[i].material;
                    closest.reflectivity = cubes[i].reflectivity;
                    closest.refractiveIndex = 1.5;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                }
            }
        }

        // Sphere intersections
        for (int i = 0; i < spheres.length(); i++) {
            float t;
            if (intersectSphere(ray, spheres[i], t)) {
                if (t < closest.t) {
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + ray.direction * closest.t;
                    closest.normal = normalize(closest.point - spheres[i].center);
                    closest.color = spheres[i].color;
                    closest.material = spheres[i].material;
                    closest.reflectivity = spheres[i].reflectivity;
                    closest.refractiveIndex = spheres[i].refractiveIndex;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                    
                    if(!closest.frontFace){
                        closest.normal = -closest.normal;
                    }
                }
            }
        }
        return closest;
    }

    // refraction
    vec3 refraction(vec3 I, vec3 N, float eta) {
        float cosine = dot(-I, N);
        float cosinet = 1.0 - (eta * eta) * (1.0 - cosine * cosine);
        if(cosinet < 0.0){
            return vec3(0.0);
        }

        return eta * I + (eta * cosine - sqrt(cosinet)) * N;
    }

    // Schlick approximation
    float schlick(float cosine, float ref_idx) {
        float F0 = (1.0 - ref_idx) / (1.0 + ref_idx);
        F0 = F0 * F0;
        return F0 + (1.0 - F0) * pow((1.0 - cosine), 5.0);
    }

    vec3 trace(Ray ray, int maxDepth) {
        vec3 color = vec3(0.0);

        //attenuation is optional
        vec3 attenuation = vec3(1.0);

        for (int depth = 0; depth < 16; depth++) {
            if (depth >= maxDepth) break;

            HitData lightHit = traceScene(ray, true);
            if (lightHit.hit && lightHit.material == MATERIAL_EMISSION){
                color += lightHit.color * attenuation;
                break;
            }

            HitData hit = traceScene(ray, false);

            if (!hit.hit) {
                color += vec3(0.443, 0.561, 0.722) * attenuation;
                break;
            }

            vec3 lightDir = normalize(lightSphere.center - hit.point);
            float lightDist = length(lightSphere.center - hit.point);

            Ray shadowRay = Ray(hit.point + hit.normal * epsilon, lightDir);
            HitData shadowHit = traceScene(shadowRay, false);
            
            float inShadow = 1.0;
            if (shadowHit.hit && shadowHit.t < lightDist) {
                inShadow = 0.5;
            }
            else{
                inShadow = 1.0;
            }

            float diffuse = max(dot(lightDir, hit.normal), 0.0);
            vec3 directLight = hit.color * diffuse * inShadow * lightSphere.color;
            vec3 ambientLight = hit.color * u_ambientStrength;
            vec3 lighting = directLight + ambientLight;

            if (hit.material == MATERIAL_DIFFUSE) {
                
                color += attenuation * lighting;
                break;

            } else if (hit.material == MATERIAL_REFRACTIVE) {
                
                vec3 direction;
                float eta;
                if(hit.frontFace){
                    eta = 1.0 / hit.refractiveIndex;
                }
                else{
                    eta = hit.refractiveIndex;
                }

                float cosine = abs(dot(ray.direction, hit.normal));
                float sintheta = sqrt(1.0 - cosine * cosine);
                vec3 refractionDirection = refraction(ray.direction, hit.normal, eta);
                float schlick_value = schlick(cosine, hit.refractiveIndex);

                bool total_internel_reflectioin = eta * sintheta > 1.0;
                if (total_internel_reflectioin || schlick_value > 0.5) {
                    //direction = reflection ray
                    
                    direction = reflect(ray.direction, hit.normal);
                } else {
                    //direction = refraction ray
                    
                    direction = refractionDirection;
                }

                ray = Ray(hit.point + direction * epsilon, direction);
                attenuation *= hit.color;

            } else {
                
                color += attenuation * directLight + ambientLight;
                attenuation *= hit.reflectivity;
                ray = Ray(hit.point + hit.normal * 0.001, reflect(ray.direction, hit.normal));
            }

            //attenuation *= 0.9;

            if (length(attenuation) < 0.01) break;
        }

        return color;
    }

    void main() {
        initScene(u_time);

        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

        vec3 origin = vec3(0.0, 0.0, 2.0);
        vec3 direction = normalize(vec3(uv, -1.5));

        Ray ray = Ray(origin, direction);
        vec3 color = trace(ray, u_maxBounces);

        color = pow(color, vec3(1.0 / 2.2));

        fragColor = vec4(color, 1.0);
    }
</script>

<script>
    (function() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported in this browser');
            throw new Error('WebGL 2 not supported');
        }

        const vsEditor = document.getElementById('vsEditor');
        const fsEditor = document.getElementById('fsEditor');

        const vertexShaderSource = document.getElementById('vertex-shader').textContent;
        const fragmentShaderSource = document.getElementById('fragment-shader').textContent;

        // Initialize editors with shader source
        vsEditor.value = vertexShaderSource;
        fsEditor.value = fragmentShaderSource;

        let program, positionLocation, resolutionLocation, timeLocation, maxBouncesLocation, ambientStrengthLocation, speedloc, bottleloc, mirrorloc;
        let vao, positionBuffer;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);

            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(prog));
            }

            return prog;
        }

        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        // Initialize buffers
        function initBuffers() {
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
        }

        function initShaderProgram() {
            try {
                program = createProgram(gl, vsEditor.value, fsEditor.value);
                gl.useProgram(program);
                positionLocation = gl.getAttribLocation(program, 'position');
                resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                timeLocation = gl.getUniformLocation(program, 'u_time');
                maxBouncesLocation = gl.getUniformLocation(program, 'u_maxBounces');
                ambientStrengthLocation = gl.getUniformLocation(program, 'u_ambientStrength');
                speedloc = gl.getUniformLocation(program, 'u_speed');
                bottleloc = gl.getUniformLocation(program, 'u_bottle');
                mirrorloc = gl.getUniformLocation(program, 'u_mirror');
                initBuffers();
            } catch (e) {
                console.error(e);
            }
        }

        initShaderProgram();

        // Hot compile when any input in the playground text area
        vsEditor.onkeyup = initShaderProgram;
        fsEditor.onkeyup = initShaderProgram;

        let maxBounces = 8;
        let ambientStrength = 0.2;
        let speed = 1;
        let bottle = 0;
        let mirror = false;
        // UI Controls
        let bottleType = 'none';
        let mode = 'normal';

        // Bottle type buttons
        document.querySelectorAll('.bottle-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.bottle-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                bottleType = this.id.replace('btn-', '');
                if(bottleType == "none"){
                    bottle = 0;
                }
                else if(bottleType == "sphere"){
                    bottle = 1;
                }
                else if (bottleType == "jar"){
                    bottle = 2;
                }
            });
        });

        // Mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                mode = this.id.replace('btn-', '');
                if(mode == "normal"){
                    mirror = false;
                }
                else{
                    mirror = true;
                }
            });
        });

        // Speed slider
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        speedSlider.addEventListener('input', function() {
            speed = this.value / 100.0; 
            speedValue.textContent = speed.toFixed(2);
        });

        // Bounces slider
        const bouncesSlider = document.getElementById('bounces-slider');
        const bouncesValue = document.getElementById('bounces-value');
        bouncesSlider.addEventListener('input', function() {
            maxBounces = parseInt(this.value);
            bouncesValue.textContent = maxBounces;
        });

        const strengthSlider = document.getElementById('strength-slider');
        const strengthValue = document.getElementById('strength-value');
        strengthSlider.addEventListener('input', function() {
            ambientStrength = this.value / 100.0;
            strengthValue.textContent = ambientStrength
        });

        let startTime = Date.now();
        function render() {
            const time = (Date.now() - startTime) / 1000.0;

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, time);
            gl.uniform1i(maxBouncesLocation, maxBounces);
            gl.uniform1f(ambientStrengthLocation, ambientStrength);
            gl.uniform1f(speedloc, speed);
            gl.uniform1i(bottleloc, bottle);
            gl.uniform1f(mirrorloc, mirror);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    })();
</script>

</body>
</html>